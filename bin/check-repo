#!/usr/bin/env python
from repo_scraper.GitChecker import GitChecker 
from repo_scraper import constants
import argparse
import re

parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", action="store_true", help="prints all results, including non-matches and warnings")
parser.add_argument("-e", "--extensions",
    help='''Comma-separated extensions, files that don't match any of these will raise a warning.
         If empty, uses default list: %s ''' % constants.DEFAULT_EXTENSIONS_FORMAT)
args = parser.parse_args()

results_to_print = ['ALERT']
if args.verbose:
    results_to_print += ['WARNING', 'NOTHING']

if args.extensions:
    allowed_extensions = re.compile(',\s*\.?').split(args.extensions.lower())
else:
    allowed_extensions = constants.DEFAULT_EXTENSIONS

print 'Allowed extensions: %s' %  reduce(lambda x,y: x+', '+y, allowed_extensions)

#Create an instance of git checkerparser.add_argument("-v", "--verbose", action="store_true", help="prints all results, including no matches and warnings")
gc = GitChecker(allowed_extensions=allowed_extensions)

#Get the generator that will turn one resul per file modified in each
#commit
file_traverser =  gc.file_traverser()

for result in file_traverser:
    if result.result_type in results_to_print:
        print result

#Checkout master
#print 'git checkout master'
#p = subprocess.Popen(['git', 'checkout', 'master'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#p.communicate()