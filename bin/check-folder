#!/usr/bin/env python
from repo_scraper.FolderChecker import FolderChecker
from repo_scraper import constants
import argparse
import re
import sys

parser = argparse.ArgumentParser()
parser.add_argument("directory", help="the directory you want to check", type=str)
parser.add_argument("-i", "--ignore", help="optional ignore file", type=str)
parser.add_argument("-v", "--verbose", action="store_true", help="prints all results, including non-matches and warnings")
parser.add_argument("-e", "--extensions",
    help='''Comma-separated extensions, files that don't match any of these will raise a warning.
         If empty, uses default list: %s ''' % constants.DEFAULT_EXTENSIONS_FORMAT)
args = parser.parse_args()

print ('IMPORTANT: This script is going to use the filesystem.\n'
        'Do not change any files in the directory while the script is running, have a coffee or '
        'something.\n')
continue_ = raw_input("Do you want to continue? (y/n): ")
if continue_.lower()!='y':
    sys.exit('Aborted by the user')

folder_path = args.directory
ignore_path = args.ignore

results_to_print = ['ALERT']
if args.verbose:
    results_to_print += ['WARNING', 'NOTHING']

if args.extensions:
    allowed_extensions = re.compile(',\s*\.?').split(args.extensions.lower())
else:
    allowed_extensions = constants.DEFAULT_EXTENSIONS

print 'Allowed extensions: %s' %  reduce(lambda x,y: x+', '+y, allowed_extensions)

print 'Checking folder %s...' % folder_path
if ignore_path:
    print 'Using ignore file %s\n' % ignore_path
else:
    print '\n'

#Create an instance of folder checker,
#this class will list files in all subdirectories,
#then apply ignore file rules. It provides a generator
#to check each file
fc = FolderChecker(folder_path, allowed_extensions=allowed_extensions, ignore_path=ignore_path)

#Get the generator to traverse the folder structure
file_traverser = fc.file_traverser()

for result in file_traverser:
    if result.result_type in results_to_print:
        print result